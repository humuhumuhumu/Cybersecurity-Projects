
# Comprehensive Malware Analysis: A Case Study of `apple.exe`

> *This writeup details my methodology for completing the "Skills Assessment" section of the "Introduction to Malware Analysis" module from Hack The Box Academy.*

## 1. The Challenge: An Overview

In this investigation, I was tasked with performing a comprehensive, multi-faceted analysis of a malware sample, `apple.exe`. The objective was to combine static, dynamic, and code analysis techniques to build a complete profile of the malware's capabilities, from its basic properties to its persistence mechanisms, network communications, and data encryption methods.

---

## 2. Tools Used

* **Static Analysis**: `md5sum`, `strings`, `IDA Freeware`, `PEiD`
* **Dynamic Analysis**: `Noriben`, `INetSim`, `Wireshark`, `Process Monitor`
* **Code Analysis**: `x64dbg`
* **Utilities**: `wget`, `unzip`, `python http.server`, `xfreerdp`

---

## 3. Investigation & Methodology

The analysis followed a logical progression, starting with lab setup and static triage before escalating to more complex dynamic and code-level investigation.

### 3.1. Lab Setup & File Transfer

The first step was to acquire the malware sample and transfer it to the isolated Windows analysis VM.

```bash
wget https://academy.hackthebox.com/storage/resources/additional_samples.zip
unzip additional_samples.zip

# Host the directory containing apple.exe via a simple Python web server
python -m http.server 8000
````

I then used `xfreerdp` to connect to the Windows VM. From there, I opened a browser, navigated to the Linux host's IP address on port 8000, and downloaded `apple.exe` to the desktop.

### 3.2. Static Analysis (Initial Triage)

I began by gathering basic file properties to form an initial assessment. I calculated the MD5 hash for identification and then checked for common packing techniques.

```bash
# On Linux
md5sum additional_samples/apple.exe
# On Windows
Get-FileHash -Algorithm MD5 .\apple.exe
# 1c7243c8f3586b799a5f9a2e4200aa92
```

While an initial review of the file's strings and a check in IDA Freeware did not reveal obvious packer signatures, loading the sample into **PEiD** returned an error: **"not a valid PE file."** This was a critical early finding, suggesting the file might be corrupted or use anti-analysis techniques to interfere with standard PE parsing tools.

*Caption: PEiD failing to parse `apple.exe`, an early indicator of the sample's unusual structure.*

### 3.3. Behavioral Analysis with Noriben

To get a quick overview of the malware's behavior, my first dynamic analysis step was to execute it in a sandbox monitored by **Noriben**. The logs revealed that `apple.exe` created several files in the `AppData` directory, including a suspicious file named **`brbconfig.tmp`**. However, the logs did not contain any clear network indicators like a C2 domain, which meant I had to escalate my analysis.

*Caption: Noriben output showing `apple.exe` creating the `brbconfig.tmp` file.*

### 3.4. Network Analysis (Finding the C2 with Wireshark)

Since Noriben didn't reveal the C2 domain, I moved to a direct network analysis approach. First, I configured **INetSim** on my Linux host to act as a network sinkhole.

```bash
# Edit the INetSim configuration file
sudo nano /etc/inetsim/inetsim.conf

# Uncomment and set the following values to the Linux host's IP
service_bind_address 10.10.15.27
dns_default_ip 10.10.15.27
```

After starting INetSim and setting the Windows VM's DNS to point to my Linux host, I ran **Wireshark** and executed `apple.exe`. To find the malicious traffic, I applied a specific filter:

```
dns and ip.dst==10.10.15.27
```

This filter immediately isolated three DNS queries. After filtering out the legitimate Microsoft traffic (`ctldl.windowsupdate.com`, `checkappexec.microsoft.com`), I was left with the true C2 domain: **`brb.3dtuts.by`**.

*Caption: Wireshark capture showing the filtered DNS query for the C2 domain `brb.3dtuts.by`.*

### 3.5. Code Analysis (Finding the Decryption Routine)

The final task was to understand how the malware processed the `brbconfig.tmp` file. My hypothesis was that the file was encrypted. To find the decryption routine, I loaded `apple.exe` into **`x64dbg`**.

My initial attempt—searching for ".tmp" strings and setting breakpoints—was inefficient. The correct method was to set a breakpoint on the `ReadFile` API call. After the breakpoint was hit, I stepped through the code until the execution flow returned from the Windows DLLs to the main `apple.exe` module. Immediately upon returning, the program called the **`CryptDecrypt`** function, confirming this was the routine used to decrypt the `.tmp` file.

*Caption: The `x64dbg` debugger showing the execution flow returning from a `ReadFile` call directly into the `CryptDecrypt` function.*

-----

## 4\. The Persistence Mystery: A Critical Lesson

A significant challenge was confirming the malware's persistence mechanism. The lab indicated that it modifies the `Software\Microsoft\Windows\CurrentVersion\Run` registry key. However, my analysis with both **Noriben** and **Process Monitor** (using a path filter for `CurrentVersion\Run`) showed no direct write operations to this key. I still do not know how the modification is achieved.

This discrepancy was a crucial lesson: **tools have blind spots.** The malware employs an advanced or indirect technique that was not detected by my initial set of monitoring tools. This highlights the importance of using multiple analysis methods and understanding that a lack of evidence from one tool is not conclusive proof of absence.

-----

## 5\. Conclusion & Key Findings

This comprehensive analysis successfully combined multiple disciplines to build a detailed profile of an evasive malware sample.

  * **Static Properties**: The malware is a non-standard PE file with an MD5 hash of `1c7243c8f3586b799a5f9a2e4200aa92`.
  * **Behavior**: It drops a configuration file named `brbconfig.tmp`.
  * **Network**: It communicates with a C2 server located at `brb.3dtuts.by`.
  * **Evasion**: It uses an advanced technique to achieve persistence that evades standard monitoring tools.
  * **Code**: It uses the `CryptDecrypt` function to decrypt its configuration file.
